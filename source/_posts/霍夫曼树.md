---
title: 霍夫曼树
tags:
  - Data Structure
  - Algorithm
url: 169.html
id: 169
categories:
  - Data Strcture
keywords: Data Structure
abbrlink: c01a18e7
date: 2017-11-12 00:25:10
---

## Huffman Codes
In 1953, David A. Huffman published his paper "A Method for the Construction of Minimum-Redundancy Codes", and hence printed his name in the history of computer science. As a professor who gives the final exam problem on Huffman codes, I am encountering a big problem: the Huffman codes are NOT unique. For example, given a string "aaaxuaxz", we can observe that the frequencies of the characters 'a', 'x', 'u' and 'z' are 4, 2, 1 and 1, respectively. We may either encode the symbols as {'a'=0, 'x'=10, 'u'=110, 'z'=111}, or in another way as {'a'=1, 'x'=01, 'u'=001, 'z'=000}, both compress the string into 14 bits. Another set of code can be given as {'a'=0, 'x'=11, 'u'=100, 'z'=101}, but {'a'=0, 'x'=01, 'u'=011, 'z'=001} is NOT correct since "aaaxuaxz" and "aazuaxax" can both be decoded from the code 00001011001001. The students are submitting all kinds of codes, and I need a computer program to help me determine which ones are correct and which ones are not.

**Input Specification:**
Each input file contains one test case. For each case, the first line gives an integer N (2≤N≤63), then followed by a line that contains all the N distinct characters and their frequencies in the following format:

    c[1] f[1] c[2] f[2] ... c[N] f[N]
where `c[i]` is a character chosen from {'0' - '9', 'a' - 'z', 'A' - 'Z', '_'}, and `f[i]` is the frequency of `c[i]` and is an integer no more than 1000. The next line gives a positive integer M (≤1000), then followed by M student submissions. Each student submission consists of Nlines, each in the format:

    c[i] code[i]    
where `c[i]` is the `i`-th character and `code[i]` is an non-empty string of no more than 63 '0's and '1's.

**Output Specification:**
For each test case, print in each line either "Yes" if the student's submission is correct, or "No" if not. Note: The optimal solution is not necessarily generated by Huffman algorithm. Any prefix code with code length being optimal is considered correct.

**Sample Input:**
```git
    7
    A 1 B 1 C 1 D 3 E 3 F 6 G 6
    4
    A 00000
    B 00001
    C 0001
    D 001
    E 01
    F 10
    G 11
    A 01010
    B 01011
    C 0100
    D 011
    E 10
    F 11
    G 00
    A 000
    B 001
    C 010
    D 011
    E 100
    F 101
    G 110
    A 00000
    B 00001
    C 0001
    D 001
    E 00
    F 10
    G 11
```
**Sample Output:**
```git
    Yes
    Yes
    No
    No
```
这一题思路就是建一棵霍夫曼树进行霍夫曼编码，然后比较霍夫曼编码的WPL和测试数据是否相同，此外还要检查某个字母的编码是否是其他字母的前缀编码。 老师的方法是按照所给编码真的建棵树，然后去看建树的过程中是否发生冲突，我觉得有点麻烦。这里我是直接用字符串操作进行比较，具体来说就是对于每一个字母的编码是s[i]，依次比较之前字母的编码s[j]，如果与之前某个编码相同，直接break；如果遇到编码长度比当前编码长度多1位，如果s[i]与s[0,j-1]相等，那就是前缀编码，break。 最初的代码如下：
```cpp
#include <iostream>
#include <string>
using namespace std;
const int minData=0;
struct HuffmanTree
{
    int f;
    HuffmanTree *left,*right;
};
struct minHeap
{
    HuffmanTree* *data;
    int Size;
    int Capacity;
};
minHeap* Create(int maxSize)
{
    minHeap* A=new minHeap;
    A->data=new HuffmanTree*[maxSize+1];
    A->Size=0;
    A->Capacity=maxSize;
    A->data[0]->f=minData;
    return A;
}
void Insert(HuffmanTree* x,minHeap* H)
{
    int i=++H->Size;
    for(;H->data[i/2]->f>x->f;i/=2){
        H->data[i]=H->data[i/2];
    }
    H->data[i]=x;
}
minHeap* Build(minHeap* T)
{
    int parent,child,i=T->Size/2;
    HuffmanTree* temp;
    for(;i>0;i--){
        temp=T->data[i];
        for(parent=i;parent*2<=T->Size;parent=child){
            child=parent*2;
            if(child+1<=T->Size
               && T->data[child]->f>T->data[child+1]->f){
                child++;
            }
            if(temp->f<=T->data[child]->f) break;
            else T->data[parent]=T->data[child];
        }
        T->data[parent]=temp;
    }
    return T;
}
HuffmanTree* Delete(minHeap *T)
{
    int parent,child;
    HuffmanTree *minItem=T->data[1],*temp=T->data[T->Size--];
    for(parent=1;parent*2<=T->Size;parent=child){
        child=parent*2;
        if(child+1<=T->Size
           && T->data[child]->f>T->data[child+1]->f){
            child++;
        }
        if(temp->f<=T->data[child]->f) break;
        else T->data[parent]=T->data[child];
    }
    T->data[parent]=temp;
    return minItem;
}
HuffmanTree* BuildHuffmanTree(int m,minHeap* H)
{
    HuffmanTree* T;
    for(int i=0;i<m;i++){
        T=new HuffmanTree;
        T->left=Delete(H);
        T->right=Delete(H);
        T->f=T->left->f+T->right->f;
        Insert(T,H);
    }
    T=Delete(H);
    return T;
}
int wpl(HuffmanTree* T,int h)
{
    if(!T->left && !T->right) return h*(T->f);
    else return wpl(T->left,h+1) + wpl(T->right,h+1);
}
void check(int n,int *freq,HuffmanTree* T)
{
    int i,j,sum=0;
    char c;
    string s[n];
    for(i=0;i<n;i++){
        cin>>c>>s[i];
        if(s[i].size()>n-1) break;
        for(j=0;j<i;j++){
            if(s[i].size()<s[j].size()){
                if(s[j].find(s[i])>=0) break;
            }
        }
        if(j<i) break;
        sum+=s[i].size()*freq[i];
    }
    if(i<n || sum!=wpl(T,0)) cout<<"No"<<endl;
}
int main()
{
    int m,n;
    char c;
    cin>>m;
    int freq[m];
    minHeap* H=Create(m);
    HuffmanTree* T;
    for(int i=0;i<m;i++){
        cin>>c>>freq[i];
        HuffmanTree* node=new HuffmanTree;
        node->f=freq[i];
        node->left=node->right=NULL;
        H->data[i+1]=node;
    }
    H=Build(H);
    T=BuildHuffmanTree(m,H);
    cin>>n;
    for(int i=0;i<n;i++){
        check(m,freq,T);
    }

    return 0;
}
```
既然是最初，那当然是错的了，找了好久没发现错误，后来看了别人的代码才发现bug在哪。。 

是这样的，建霍夫曼树之前，我们要先建个最小堆，最小堆的数组里存的是什么呢？当然不能是频率值，不然后面建树超级麻烦。我刚开始就是在里面存的指向树节点的指针变量，这样数组data就成了指针变量数组，进行堆操作的时候比较数组元素指向的节点的f值即可，看起来好像没什么问题，我当初也是这么想的。。问题还就出在这里，原因我暂时还没找到，可能是指针数组哪的地方给用错了？不过把数组元素换成节点之后就可以了。。 最终代码如下：
```cpp
#include <iostream>
#include <string>
using namespace std;
const int minData=-1;
struct HuffmanTree
{
    int f;
    HuffmanTree *left=NULL;
    HuffmanTree *right=NULL;
};
struct minHeap
{
    HuffmanTree *data;
    int Size=0;
};
minHeap* Create(int maxSize)
{
    minHeap* H=new minHeap;
    H->data=new HuffmanTree[maxSize+1];
    H->data[0].f=minData;
    return H;
}
void Insert(HuffmanTree* x,minHeap* H)
{
    int i=++H->Size;
    for(;H->data[i/2].f>x->f;i/=2){
        H->data[i]=H->data[i/2];
    }
    H->data[i]=*x;
}
HuffmanTree* Delete(minHeap *H)
{
    int parent,child;
    HuffmanTree temp=H->data[H->Size--];
    HuffmanTree *minItem=new HuffmanTree;
    *minItem=H->data[1];
    for(parent=1;parent*2<=H->Size;parent=child){
        child=parent*2;
        if(child+1<=H->Size
           && H->data[child].f>H->data[child+1].f){
            child++;
        }
        if(temp.f<=H->data[child].f) break;
        else H->data[parent]=H->data[child];
    }
    H->data[parent]=temp;
    return minItem;
}
HuffmanTree* BuildHuffmanTree(int m,minHeap* H)
{
    HuffmanTree* T;
    for(int i=0;i<m-1;i++){
        T=new HuffmanTree;
        T->left=Delete(H);
        T->right=Delete(H);
        T->f=T->left->f+T->right->f;
        Insert(T,H);
    }
    return Delete(H);
}
int wpl(HuffmanTree* T,int h)
{
    if(!T->left && !T->right) return h*(T->f);
    else return wpl(T->left,h+1) + wpl(T->right,h+1);
}
void check(int n,int freq[],HuffmanTree* T)
{
    int i,j,is=1,sum=0;
    char c;
    string s[n];
    for(i=0;i<n;i++){
        cin>>c>>s[i];
        if(s[i].size()>n-1) break;
        for(j=0;j<i;j++){
            if(s[i]==s[j]) break;
            if(s[i].size()+1==s[j].size()){
                if(s[i]==s[j].substr(0,s[i].size())) break;
            }
        }
        if(j<i) break;
        sum+=s[i].size()*freq[i];
    }
    if(i<n || sum!=wpl(T,0)) is=0;
    for(;i<n-1;i++) cin>>c>>s[i];
    if(is) cout<<"Yes"<<endl;
    else cout<<"No"<<endl;
}
int main()
{
    int m,n;
    char c;
    cin>>m;
    int freq[m];
    minHeap* H=Create(m);
    HuffmanTree* T;
    for(int i=0;i<m;i++){
        cin>>c>>freq[i];
        HuffmanTree* node=new HuffmanTree;
        node->f=freq[i];
        Insert(node,H);
    }
    T=BuildHuffmanTree(m,H);
    cin>>n;
    for(int i=0;i<n;i++){
        check(m,freq,T);
    }
    return 0;
}
```
